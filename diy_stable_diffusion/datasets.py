# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05 copy datasets.ipynb.

# %% ../nbs/05 copy datasets.ipynb 1
from __future__ import annotations
import math,numpy as np,matplotlib.pyplot as plt
from operator import itemgetter
from itertools import zip_longest
import fastcore.all as fc

from torch.utils.data import default_collate

from .training import *

# %% auto 0
__all__ = ['inplace', 'collate_dict', 'show_image', 'subplots', 'get_grid', 'show_images', 'DataLoaders']

# %% ../nbs/05 copy datasets.ipynb 28
def inplace(f):
    def _f(b):
        f(b)
        return b
    return _f

# %% ../nbs/05 copy datasets.ipynb 39
def collate_dict(ds):
    getter = itemgetter(*ds.features)
    def _f(b):
        return getter(default_collate(b))
    return _f

# %% ../nbs/05 copy datasets.ipynb 44
@fc.delegates(plt.Axes.imshow)
def show_image(im, ax=None, figsize=None, title=None, noframe=True, **kwargs):
    '''Show a PIL or pytorch tensor on ax'''
    if im is None:
        return None
    
    if fc.hasattrs(im, ('cpu', 'permute', 'detach')):
        im = im.detach().cpu()
        if len(im.shape) == 3 and im.shape[0] < 5:
            im = im.permute(1,2,0)
    elif not isinstance(im, np.ndarray):
        im = np.array(im)
    
    if im.shape[-1] == 1:
        im = im[...,0] # probably same as unsqueeze, right?
    if ax is None:
        _,ax = plt.subplots(figsize=figsize)

    ax.imshow(im, **kwargs)
    
    if title is not None:
        ax.set_title(title)
        
    ax.set_xticks([])
    ax.set_yticks([])
    
    if noframe:
        ax.axis('off')
    return ax

# %% ../nbs/05 copy datasets.ipynb 51
@fc.delegates(plt.subplots, keep=True)
def subplots(
    nrows:int=1,
    ncols:int=1,
    figsize:tuple=None,
    imsize:int=3, # in inches
    suptitle:str=None,
    **kwargs
):
    if figsize is None:
        figsize = (ncols*imsize, nrows*imsize)
    fig,ax = plt.subplots(nrows, ncols, figsize=figsize, **kwargs)

    if suptitle is not None:
        fig.suptitle(suptitle)

    if nrows * ncols == 1:
        ax = np.array([ax])
    return fig, ax

# %% ../nbs/05 copy datasets.ipynb 54
def get_grid(
    n:int, 
    nrows:int=None,
    ncols:int=None,
    title:str=None,
    weight:str='bold',
    size:int=14,
    **kwargs,
):
    if nrows:
        ncols = ncols or int(np.ceil(n/nrows))
    elif ncols:
        nrows = nrows or int(np.ceil(n/ncols))
    else:
        nrows = int(math.sqrt(n))
        ncols = int(np.ceil(n/nrows))
    fig, axes = subplots(nrows, ncols, **kwargs)
    
    for i in range(n, nrows * ncols):
        axes.flat[i].set_axis_off()
    
    if title is not None:
        fig.suptitle(title, weight=weight, size=size)
    
    return fig, axes
    

# %% ../nbs/05 copy datasets.ipynb 57
@fc.delegates(subplots)
def show_images(ims:list,
                nrows:int|None=None,
                ncols:int|None=None,
                titles:list|None=None,
                **kwargs):
    axes = get_grid(len(ims), nrows, ncols, **kwargs)[1].flat
    for im, title, ax in zip_longest(ims, titles or [], axes):
        show_image(im, ax=ax, title=title)

# %% ../nbs/05 copy datasets.ipynb 61
class DataLoaders:
    def __init__(self, dl_train, dl_valid):
        self.train = dl_train
        self.valid = dl_valid
    
    @classmethod
    def from_dd(cls, ds_dict, batch_size, as_tuple=True, **kwargs):
        f = collate_dict(ds_dict['train'])
        return cls(*get_dls(*ds_dict.values(), bs=batch_size, collate_fn=f, **kwargs))
